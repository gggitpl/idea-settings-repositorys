<application>
  <component name="AppStorage">
    <histories>
      <item value="* Checks the current authentication token and passes it to the AuthenticationManager" />
      <item value="* Processes a HTTP request's BASIC authorization headers, putting the result into the" />
      <item value="&quot;There is no client authentication. Try adding an appropriate authentication filter.&quot;);" />
      <item value="// A refresh token has its own default scopes, so we should ignore any added by the factory here." />
      <item value="Sets a new list of custom authentication filters for the TokenEndpoint. Filters will be set upstream of the * default BasicAuthenticationFilter." />
      <item value="Adds a new custom authentication filter for the TokenEndpoint. Filters will be set upstream of the default * BasicAuthenticationFilter." />
      <item value="super.setAuthenticated(true); // must use super, as we override" />
      <item value="* Constructor which sets the &lt;tt&gt;defaultTargetUrl&lt;/tt&gt; property of the base class." />
      <item value="// Use the DefaultSavedRequest URL" />
      <item value="Called by a class when it wishes a new authentication details instance to be * created." />
      <item value="* {@code RequestCache} which stores the {@code SavedRequest} in the HttpSession." />
      <item value="* Set the ApplicationEventPublisher that this object runs in." />
      <item value="* Indicates if the filter chain should be continued prior to delegation to" />
      <item value="Encapsulates the redirection logic for all classes in the framework which perform * redirects." />
      <item value="Responsible for reconstituting the saved request if one is cached and it matches the * current request." />
      <item value="* Performs Http session-related functionality when a new authentication occurs." />
      <item value="// return immediately as subclass has indicated that it hasn't completed // authentication" />
      <item value="If the request is already authenticated we can assume that this // filter is not needed" />
      <item value="/** * Filter base class that aims to guarantee a single execution per request * dispatch, on any servlet container. It provides a {@link #doFilterInternal} * method with HttpServletRequest and HttpServletResponse arguments. *" />
      <item value="// If authentication fails the type is &quot;Form&quot;" />
      <item value="authenticationManager must be specified" />
      <item value="// Unknown exception, typically a wrapper with a common MVC exception as cause // (since @ExceptionHandler type declarations also match first-level causes): // We only deal with top-level MVC exceptions here, so let's rethrow the given // exception for further processing through the HandlerExceptionResolver chain." />
      <item value="/** * Returns &lt;code&gt;true&lt;/code&gt; if this &lt;Code&gt;AuthenticationProvider&lt;/code&gt; supports the * indicated &lt;Code&gt;Authentication&lt;/code&gt; object. * &lt;p&gt; * Returning &lt;code&gt;true&lt;/code&gt; does not guarantee an * &lt;code&gt;AuthenticationProvider&lt;/code&gt; will be able to authenticate the presented * instance of the &lt;code&gt;Authentication&lt;/code&gt; class. It simply indicates it can * support closer evaluation of it. An &lt;code&gt;AuthenticationProvider&lt;/code&gt; can still * return &lt;code&gt;null&lt;/code&gt; from the {@link #authenticate(Authentication)} method to * indicate another &lt;code&gt;AuthenticationProvider&lt;/code&gt; should be tried. * &lt;/p&gt; * &lt;p&gt; * Selection of an &lt;code&gt;AuthenticationProvider&lt;/code&gt; capable of performing * authentication is conducted at runtime the &lt;code&gt;ProviderManager&lt;/code&gt;. * &lt;/p&gt; * * @param authentication * * @return &lt;code&gt;true&lt;/code&gt; if the implementation can more closely evaluate the * &lt;code&gt;Authentication&lt;/code&gt; class presented */" />
      <item value="// Default methods are public non-abstract, non-synthetic, and non-static instance methods // declared in an interface. // method.isDefault() is not sufficient for our usage as it does not check // for synthetic methods. As a result, it picks up overridden methods as well as actual default // methods." />
      <item value="&quot;description&quot;: &quot;Enables the use of the OK HTTP Client by Feign.&quot;," />
      <item value="&quot;description&quot;: &quot;If true, an OpenFeign client will be wrapped with a Hystrix circuit breaker.&quot;," />
      <item value="&quot;sourceType&quot;: &quot;org.springframework.cloud.openfeign.support.FeignHttpClientProperties&quot;," />
      <item value="&quot;description&quot;: &quot;Enables the use of the Apache HTTP Client by Feign.&quot;," />
      <item value="&quot;description&quot;: &quot;Enables the response from Feign to be compressed.&quot;," />
      <item value="&quot;description&quot;: &quot;Enables the request sent by Feign to be compressed.&quot;," />
      <item value="SecurityContextHolder now cleared, as request processing completed" />
      <item value="RunAsManager did not change Authentication object" />
      <item value="Authorization successful" />
      <item value="SECONDS" />
      <item value="&quot;description&quot;: &quot;Deprecated property to enable Ribbon RestClient.&quot;," />
      <item value="&quot;sourceType&quot;: &quot;org.springframework.cloud.netflix.ribbon.RibbonEagerLoadProperties&quot;," />
      <item value="{ &quot;groups&quot;: [ { &quot;name&quot;: &quot;ribbon&quot;, &quot;type&quot;: &quot;org.springframework.cloud.netflix.ribbon.ServerIntrospectorProperties&quot;, &quot;sourceType&quot;: &quot;org.springframework.cloud.netflix.ribbon.ServerIntrospectorProperties&quot; }, { &quot;name&quot;: &quot;ribbon.eager-load&quot;, &quot;type&quot;: &quot;org.springframework.cloud.netflix.ribbon.RibbonEagerLoadProperties&quot;, &quot;sourceType&quot;: &quot;org.springframework.cloud.netflix.ribbon.RibbonEagerLoadProperties&quot; } ], &quot;properties&quot;: [ { &quot;name&quot;: &quot;eureka.client.healthcheck.enabled&quot;, &quot;type&quot;: &quot;java.lang.Boolean&quot;, &quot;description&quot;: &quot;Enables the Eureka health check handler.&quot;, &quot;defaultValue&quot;: true }, { &quot;name&quot;: &quot;ribbon.eager-load.clients&quot;, &quot;type&quot;: &quot;java.util.List&lt;java.lang.String&gt;&quot;, &quot;sourceType&quot;: &quot;org.springframework.cloud.netflix.ribbon.RibbonEagerLoadProperties&quot; }, { &quot;name&quot;: &quot;ribbon.eager-load.enabled&quot;, &quot;type&quot;: &quot;java.lang.Boolean&quot;, &quot;sourceType&quot;: &quot;org.springframework.cloud.netflix.ribbon.RibbonEagerLoadProperties&quot;, &quot;defaultValue&quot;: false }, { &quot;name&quot;: &quot;ribbon.http.client.enabled&quot;, &quot;type&quot;: &quot;java.lang.Boolean&quot;, &quot;description&quot;: &quot;Deprecated property to enable Ribbon RestClient.&quot;, &quot;defaultValue&quot;: false }, { &quot;name&quot;: &quot;ribbon.okhttp.enabled&quot;, &quot;type&quot;: &quot;java.lang.Boolean&quot;, &quot;description&quot;: &quot;Enables the use of the OK HTTP Client with Ribbon.&quot;, &quot;defaultValue&quot;: false }, { &quot;name&quot;: &quot;ribbon.restclient.enabled&quot;, &quot;type&quot;: &quot;java.lang.Boolean&quot;, &quot;description&quot;: &quot;Enables the use of the deprecated Ribbon RestClient.&quot;, &quot;defaultValue&quot;: false }, { &quot;name&quot;: &quot;ribbon.secure-ports&quot;, &quot;type&quot;: &quot;java.util.List&lt;java.lang.Integer&gt;&quot;, &quot;sourceType&quot;: &quot;org.springframework.cloud.netflix.ribbon.ServerIntrospectorProperties&quot; } ], &quot;hints&quot;: [] }" />
      <item value="### Digest authorization with variables." />
      <item value="* Constant to use while parsing and formatting parameter maps for OAuth2 requests" />
      <item value="requests" />
      <item value="and" />
      <item value="// parameters map will be stored without change in the AuthorizationRequest object once it is created." />
      <item value="// query off of the authorization request instead of referring back to the parameters map. The contents of the" />
      <item value="// Pull out the authorization request first, using the OAuth2RequestFactory. All further logic should" />
      <item value="to" />
      <item value="continue" />
      <item value="// gh-807 Approvals (if any) should only be removed when Refresh Tokens are removed (or expired)" />
      <item value="but" />
      <item value="reuse Refresh Token" />
      <item value="token Converter" />
    </histories>
    <option name="languageScores">
      <map>
        <entry key="CHINESE" value="51" />
        <entry key="ENGLISH" value="52" />
        <entry key="CHINESE_TRADITIONAL" value="1" />
      </map>
    </option>
  </component>
</application>